function steerCmd = lateralControllerStanley(refPose, currPose, currVelocity, Direction ,PositionGain ,Wheelbase,MaxSteeringAngle)
%lateralControllerStanley Compute steering angle for path following
%   steerCmd = lateralControllerStanley(refPose, currPose, currVelocity) 
%   computes the steering angle command steerCmd, in degrees, using the  
%   Stanley method. steerCmd controls the current pose of the vehicle 
%   currPose with respect to the desired reference pose refPose, at the  
%   longitudinal velocity currVelocity.
%
%   The refPose, specified as [x, y, theta], contains the position of the 
%   reference point on the path and the orientation of the path at the 
%   point. In forward motion, the reference point is the nearest point on  
%   the path to the center of the front axle of the vehicle. In reverse   
%   motion, the reference point is the nearest point on the path to the 
%   center of the rear axle.
%      
%   In both forward and reverse motion, the currPose, specified as 
%   [x, y, theta], represents the position of the center of the rear axle 
%   and the heading angle of the vehicle. 
%
%   steerCmd = lateralControllerStanley(..., Name, Value) specifies  
%   additional name-value pair arguments as described below:
%   
%   'Direction'             Driving direction of the vehicle: 1 for forward
%                           motion and -1 for reverse motion.                          
%
%                           Default: 1
%
%   'PositionGain'          A positive scalar that describes how the  
%                           position error affects the output magnitude.  
%                           Typical values range from 1 to 5. A larger gain  
%                           results in a more aggressive control using a 
%                           larger steering angle.
%
%                           Default: 2.5
%
%   'Wheelbase'             Wheelbase of the vehicle. It is only used in
%                           computing the steering command for forward 
%                           motion.
%
%                           Default: 2.8 (m)
% 
%   'MaxSteeringAngle'      A positive scalar that represents the maximum 
%                           allowable steering angle of the vehicle. Its 
%                           range is between 0 and 180. The output command
%                           steerCmd is saturated to the range of
%                           [-MaxSteeringAngle MaxSteeringAngle].
%                       
%                           Default: 35 (degrees)  


narginchk(3, 11);

% Parse and check inputs
direction, gain, wheelbase, maxSteer

% Clip heading angle to be within [0, 360) and convert to radian
refPose(3) = matlabshared.planning.internal.angleUtilities.convertAndWrapTo2Pi(refPose(3));
currPose(3)= matlabshared.planning.internal.angleUtilities.convertAndWrapTo2Pi(currPose(3));

% Compute position error
posError = computePositionError(refPose, currPose, direction, wheelbase);

% Compute heading error
angError = computeSteeringAngleError(refPose, currPose);

% Avoid oversensitiveness at low speeds
Ksoft = 1;

% Compute steering angle by implementing equation (5) in reference [1]
if direction == 1
    delta = -(angError + atan(gain * posError/(Ksoft+currVelocity)));
else
    % In reverse motion, rear wheel velocity is required to compute the
    % steering angle. However, this will require the current steering angle 
    % as an input. To simplify the design without affecting the performance
    % of the controller, the front wheel velocity is used.
    vr    = currVelocity;
    delta = angError + atan(gain * posError/(-Ksoft+vr));
end

% Saturate and convert to degree
steerCmd = saturate(rad2deg(delta), maxSteer);

end

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Helper function
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function delta = saturate(delta, maxSteeringAngle)
%saturate Saturate steering angle when it exceeds MaxSteeringAngle
delta = sign(delta) * min(abs(delta), maxSteeringAngle);
end

%--------------------------------------------------------------------------
function thetaError = computeSteeringAngleError(refPose, pose)
%computeSteeringAngleError Compute the steering angle error
thetaError = matlabshared.planning.internal.angleUtilities.angdiff(refPose(3), pose(3));

end

%--------------------------------------------------------------------------
function posError = computePositionError(refPose, pose, direction, wheelbase)
%computePositionError Compute the distance error

% Tangent direction of the reference path
tHat = [cos(refPose(3)), sin(refPose(3))];

% Tracking error vector
if direction == 1
    poseF = driving.internal.control.rearPoseToFrontPose(pose, wheelbase);
    d = poseF(1:2) - refPose(1:2);
else
    d = pose(1:2)  - refPose(1:2);
end

% Implement equation (8) in reference [2]
posError = -(d(1)*tHat(2) - d(2)*tHat(1));
end

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Parse parameters
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [direction, gain, wheelbase, maxSteer] = parseInputs( ...
    refPose, currPose, currVelocity, varargin)
%parseInputs Parse parameters for both simulation and codegen 

% Check required inputs
checkPose(refPose, 'refPose');
checkPose(currPose, 'currPose');
checkVelocity(currVelocity);

% Define default values
defaultParams = struct( ...
    'Direction', 1, ...
    'PositionGain', 2.5, ...
    'Wheelbase', 2.8, ...
    'MaxSteeringAngle', 35);

% Parse inputs
if isempty(coder.target)  % Simulation
    r = parseOptionalInputsSimulation(defaultParams, varargin{:});
else % Code generation
    r = parseOptionalInputsCodegen(defaultParams, varargin{:});
end

% Extract parameters
direction = r.Direction;
gain      = r.PositionGain;
wheelbase = r.Wheelbase;
maxSteer  = r.MaxSteeringAngle;

% Check parameters
checkDirection(direction);
checkPositionGain(gain);
checkWheelbase(wheelbase);
checkMaxSteeringAngle(maxSteer);
checkDirectionConsistency(direction, currVelocity);
end

%--------------------------------------------------------------------------
function r = parseOptionalInputsSimulation(defaultParams, varargin)
%parseOptionalInputsSimulation Parse parameters for simulation workflow

% Instantiate an input parser
parser = inputParser;

% Specify the optional parameters
parser.addParameter('Direction',        defaultParams.Direction);
parser.addParameter('PositionGain',     defaultParams.PositionGain);
parser.addParameter('Wheelbase',        defaultParams.Wheelbase);
parser.addParameter('MaxSteeringAngle', defaultParams.MaxSteeringAngle);

% Parse
parser.parse(varargin{:});
r = parser.Results;
end

%--------------------------------------------------------------------------
function r = parseOptionalInputsCodegen(defaultParams, varargin)
%parseOptionalInputsCodegen Parse parameters for codegen workflow

parms = struct( ...
    'Direction', uint32(0), ...
    'PositionGain', uint32(0), ...
    'Wheelbase', uint32(0), ...
    'MaxSteeringAngle', uint32(0));

popt = struct( ...
        'CaseSensitivity', false, ...
        'StructExpand',    true, ...
        'PartialMatching', false);

optarg = eml_parse_parameter_inputs(parms, popt, varargin{:});

direction = eml_get_parameter_value(optarg.Direction,...
    defaultParams.Direction, varargin{:});

gain = eml_get_parameter_value(optarg.PositionGain,...
    defaultParams.PositionGain, varargin{:});

wheelbase = eml_get_parameter_value(optarg.Wheelbase,...
    defaultParams.Wheelbase, varargin{:});

maxSteer = eml_get_parameter_value(optarg.MaxSteeringAngle,...
    defaultParams.MaxSteeringAngle, varargin{:});

r = struct( ...
    'Direction', direction, ...
    'PositionGain', gain, ...
    'Wheelbase', wheelbase, ...
    'MaxSteeringAngle', maxSteer);
end

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% Check inputs and parameters
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function checkPose(pose, poseName)
%checkPose Check pose input
matlabshared.planning.internal.validation.checkPose(pose, 3, poseName, mfilename);
end

%--------------------------------------------------------------------------
function checkVelocity(vel)
%checkVelocity Check velocity input
validateattributes(vel, {'double', 'single'}, ...
    {'nonnan', 'real', 'finite', 'scalar', 'nonempty'}, ...
    mfilename, 'Velocity');
end

%--------------------------------------------------------------------------
function checkDirection(direction)
%checkDirection Check driving direction
validateattributes(direction, {'double', 'single'}, ...
    {'nonnan', 'real', 'finite', 'scalar', 'nonempty'}, ...
    mfilename, 'Direction');

isValidDirection = any(direction == [1, -1]);

coder.internal.errorIf(~isValidDirection, ...
    'driving:lateralControllerStanley:invalidDirection');
end

%--------------------------------------------------------------------------
function checkDirectionConsistency(direction, velocity)
%checkDirectionConsistency Check if the direction is consistent with
%    the current velocity
isInconsistent = (velocity > 0 && direction == -1 ) || ...
                 (velocity < 0 && direction == 1 );
            
coder.internal.errorIf(isInconsistent, ...
    'driving:lateralControllerStanley:inconsistentDirection');
end

%--------------------------------------------------------------------------
function checkPositionGain(gain)
%checkGain Check controller PositionGain
validateattributes(gain, {'double', 'single'}, ...
    {'nonnan', 'real', 'finite', 'scalar', 'nonempty', 'positive'}, ...
    mfilename, 'PositionGain');
end

%--------------------------------------------------------------------------
function checkWheelbase(wheelbase)
%checkWheelbase Check Wheelbase
validateattributes(wheelbase, {'double', 'single'}, ...
    {'nonnan', 'real', 'finite', 'scalar', 'nonempty'}, ...
    mfilename, 'Wheelbase');
end

%--------------------------------------------------------------------------
function checkMaxSteeringAngle(maxSteer)
%checkMaxSteeringAngle Check MaxSteeringAngle
validateattributes(maxSteer, {'double', 'single'}, ...
    {'nonnan', 'real', 'finite', 'scalar', 'nonempty', 'positive', '<', 180}, ...
    mfilename, 'MaxSteeringAngle');
end

